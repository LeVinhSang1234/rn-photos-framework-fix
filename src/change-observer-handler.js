function updateHandler(e,n){if(e)for(let t=0;t<e.length;t++){n(e[t])}}function enumerateMoves(e,n,t,o){if(n.moves&&n.moves.length)for(let r=0;r<n.moves.length;r+=2){let l=n.moves[r],i=n.moves[r+1];o(void 0!==t?t(l,e,"move"):l,void 0!==t?t(i,e,"move"):i,l,i)}}export function indeciesIsReversedNormalOrScrambled(e,n,t){if(!e||e.length<=1)return t||"normal";if(e.map((e=>e.collectionIndex)).some((e=>void 0===e)))return"scrambled";let o;for(let n=0;n<e.length;n++){let t,r="scrambled",l=e[n].collectionIndex;if(0!==n&&e[n-1]&&(t=e[n-1].collectionIndex),void 0!==t){if(l===t+1&&(r="normal"),l===t-1&&(r="reversed"),o&&o!==r){o="scrambled";break}o=r}}return o}function getObjectIndex(e,n,t,o){const r=void 0!==e.obj&&void 0!==e.obj.collectionIndex?e.obj.collectionIndex:e.index;return void 0!==n?n(r,t,o):r}function getMissingIndecies(e,n,t){const o=[];return enumerateMoves(n,e,t,((e,t,r,l)=>{const i=e>n.length-1||e<0,c=t<=n.length-1&&t>=0;i&&c&&-1===o.indexOf(r)&&o.push(l)})),o}export function assetArrayObserverHandler(e,n,t,o,r,l){const i=indeciesIsReversedNormalOrScrambled(n,e,r);if("scrambled"===i)throw new Error("[RNPhotosFramework] You can not use the automatic update function for change observing with scrambled or undefined indecies (property collectionIndex). Please submit the assets in their original order or do the update manully");return collectionArrayObserverHandler(e,n,t,o,((e,n,t)=>{let o=0;const r=n.filter((e=>!!e));r.length>0&&(o="normal"===i?r[0].collectionIndex:r[r.length-1].collectionIndex);let l=e-o;return"reversed"===i&&(l=n.length-("insert"===t?0:1)-l),l}),((e,n,t,o)=>{if("normal"===i)for(let o=n+1;o<e.length;o++)modifyIndex(e,o,t);else if("reversed"===i)for(let o=n-1;o>=0;o--)modifyIndex(e,o,t)}),l)}function modifyIndex(e,n,t){const o=e[n];o&&("insert"===t?o.collectionIndex++:"remove"===t&&o.collectionIndex--)}export function collectionArrayObserverHandler(e,n,t,o,r,l,i){return new Promise(((c,d)=>{if(void 0!==e.hasIncrementalChanges&&!e.hasIncrementalChanges)return c(n);function s(o){if(e.moves){let t={};enumerateMoves(n,e,r,((e,r,i,c)=>{const d=e>n.length-1||e<0,s=r<=n.length-1&&r>=0;if(d&&!s)return;let a;!t[e]&&n[e]&&n[e]&&void 0!==n[e].collectionIndex&&(a=n[e].collectionIndex);let m=t[e]||n[e];!m&&o&&(m=o.find((e=>e.collectionIndex===c))),m||(console.warn("Could not find aset with collectionIndex",i),l(n,r,"remove")),t[r]=n[r],n[r]&&void 0!==n[r].collectionIndex&&m&&void 0!==m.collectionIndex&&(m.collectionIndex=n[r].collectionIndex),r<=n.length-1&&r>=0&&(n[r]=m),void 0!==a&&(n[e]={collectionIndex:a}),n=n.filter((e=>void 0!==e))}))}i&&i("move",n);let d=n.length-1;return updateHandler(e.changedObjects,(e=>{const o=getObjectIndex(e,r,n,"change");o<=d&&o>=0&&(n[o]=t(e.obj))})),i&&i("change",n),c(n)}!function(){let c=n.length-1;if(updateHandler(e.removedObjects,(e=>{const t=getObjectIndex(e,r,n,"remove");t<=c&&t>=0?(n[t]=void 0,l&&l(n,t,"remove")):l&&l(n,t,"remove")})),n=n.filter((e=>void 0!==e)),i&&i("remove",n),c=n.length-1,updateHandler(e.insertedObjects,(e=>{const o=getObjectIndex(e,r,n,"insert");if(o<=c+1&&o>=0){const r=t(e.obj);n.splice(o,0,r),l&&l(n,o,"insert",r)}else l&&l(n,o,"insert");c=n.length-1})),i&&i("insert",n),!o)return s();{const t=getMissingIndecies(e,n,r);if(i&&i("fetch",t),!t||!t.length)return s();o(t,(e=>s(e)))}}()}))}